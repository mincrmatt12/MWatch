; first: the data out


.define IRQ_HSYNC 0
.define IRQ_VSYNC 1
.define public IRQ_DONE  2   ; routed to CPU: set high on frame done; clear to _start next frame_ (so clear the inte flag then exit handler, then on next frame actually clear status)

.program ls012_dataout

;; DATAOUT: run at 24mhz, 10 cycles = 416 ns (in spec), hold time == 5 cyc, perfectly to spec    || clkdiv 4   from 96
;; HCLK:    run at 12mhz, 5 cycles = 416 ns;  1 cyc = 83ns                                       || clkdiv 8   from 96
;; VCLK:    run at 274khz                                                                        || clkdiv 350 from 96 

.wrap_target
	; reset counter
	mov x, y
pixloop:
	; sync with ls012_hclk  ( and wait for frame start )
	wait 1 irq IRQ_HSYNC         [6] ;; ------ DATAOUT ---------- HCLK -------  0 cycles (sync'd here) TODO: may need some tweaking   (loop, 10/5 cyc)
	; BEGIN OUTPUTTING               ;;                       
	                                 ;;                        1cyc (during wait postdelay) <--- clock changed (previous value asserted)
									 ;;                        2cyc (during wait postdelay)    |
	out pins, 6                      ;; 7  cyc                 3.5cyc    (actual output)  <----|  new data asserted (halfway through)
	out null, 16                     ;; 8  cyc                 4cyc
	; loop                                                                            
	jmp x--, pixloop                 ;; 9 cyc                      
	; AFTER LOOP: reset pins
	; mov pins, null
.wrap ; jump back for next line
	
.program ls012_hclk

.define thwGEN 31   ; 31 * 4 = 124 clock cycles = 10.3 us (in spec)
.define thhGCK 12   ; 10 * 4 = 40  clock cycles = ~4us

.side_set 2 opt ; sideset: BSP,GEN

.wrap_target
    mov x, y               side 0b10   [3]      ; Reset horizontal counter.
	mov pins, ~null                    [3]      ; Set BCK high for first fake reset cycle.
pixloop:   
	irq wait IRQ_HSYNC                          ; Synchronize with dataout sm (in case a FIFO underrun slowed it down)
												; There is no bug about the first clock cycle here -- we get the data ready on the falling
												; edge of the fake cycle - (2) in the datasheet - and it is sampled on the next loop around at precisely
												; the right time.
	mov pins, ~pins                             ; Flip the clock at ~50% duty (see chart in dataout)
	jmp x--, pixloop       side 0b00            ; Loop back -- also, reset GSP at this point (in case this was the first clock cycle)
	; AFTER LINE done; do GEN pulse (GCK should now have just been set to zero -- delay)
	set x, (thwGEN-3)      side 0b01   [2]      ; full clock cycle  (-1 from jump, -1 from counter)  ---- setup thwGEN
	mov pins, null                     [3]
gendelay:
	jmp x--, gendelay                  [3]      ; keep gen pulsed
public entry_point:                             ; start here to start in a waiting state
	wait 1 irq IRQ_VSYNC   side 0b00            ; sync with vertical clock (this one does a GCK pulse)
	wait 1 irq IRQ_VSYNC                        ; sync with vertical clock for after GCK toggle (ensure thsBSP >= 0)
.wrap

.program ls012_vclk

.define thsINTB_GSP 3
.define thwGCK 16 ; 16 total cycles: just under the proper time but whatever
.side_set 1 ; GSP only

.wrap_target
   irq wait IRQ_DONE                  side 0    ; wait for notification from cpu to start (and conversely, notify the CPU when frame is finished scanning)
   set pins, 0b01     [thsINTB_GSP]   side 0    ; set INTB high and wait thsINTB_GSP
   mov x, y           [thsINTB_GSP]   side 1    ; turn on GSP (via sideset) and reset vertical counter (previously set by CPU instruction)
   set pins, 0b11     [thwGCK-1]      side 1    ; Run one clock cycle with GSP high (cannot use loop because sideset)
   irq wait IRQ_VSYNC [1]             side 1    ; Acknowledge the first wait at the start of the HCLK sm
   mov pins, ~pins                    side 1    ; Flip GCK back to 0 in preparation for first line
   jmp  continue                      side 0    ; Enter main loop while also setting GSP back to 0
lineloop:
   irq wait IRQ_VSYNC [1]             side 0    ; Sync after starting HCLK output (waits till output is finished)
   mov pins, ~pins                    side 0    ; Flip clock
continue:
   irq wait IRQ_VSYNC                 side 0    ; Sync after clock is definitely pulsed (starts next line of output)
   jmp x--, lineloop                  side 0    ; Decrement line counter and loop.
   ; DONE SCREEN, one final clock cycle
   mov pins, ~null    [thwGCK-1]      side 0    ; Spec requires one final clock clock cycle
   mov pins,  null    [thwGCK-1]      side 0
   mov pins, ~null    [thwGCK-1]      side 0
   mov pins,  null    [3]             side 0
   set pins, 0b00                     side 0    ; Clear INTB
   ; CPU gets notification from irq; it should clear out the clk / whatever with some expediency 
.wrap
